classdef ZombieMetadata
    %ZOMBIEMETADATA Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        PAGE_BYTES;
        BLOCK_BYTES; 
        PAGE_ROWS;
        PAGES_NUM;
        BITS_PER_BLOCK;
        ROWS_IN_MEMORY;
        ECP_MAX_ERRORS_CORRECTED;

        Memory;
        
        spare_blocks_queue;
        paired_blocks_list;
        block_pairing_table;
        num_of_spare_blocks;
    end
    
    methods
        function obj = ZombieMetadata(page_bytes, block_bytes, pages_num, ecp_max_errors_corrected)
            obj.PAGE_BYTES = page_bytes;
            obj.BLOCK_BYTES = block_bytes; 
            obj.PAGES_NUM = pages_num; %1000;
            obj.PAGE_ROWS = PAGE_BYTES/BLOCK_BYTES;
            obj.BITS_PER_BLOCK = BLOCK_BYTES*8;
            obj.ROWS_IN_MEMORY = PAGES_NUM * PAGE_ROWS;
            obj.num_of_spare_blocks = 0;
            obj.ECP_MAX_ERRORS_CORRECTED = ecp_max_errors_corrected;
            
            obj.Memory = MemoryArray(page_bytes, block_bytes, pages_num);
            
            % -- Zombie
            obj.paired_blocks_list = zeros(PAGE_ROWS*PAGES_NUM, 1);
            obj.spare_blocks_queue = [];
            obj.block_pairing_table = zeros(PAGE_ROWS*PAGES_NUM, 1);
        end
        
        function writeToRow(obj, row_to_write, writes_performed)
            spare_block_num = obj.block_pairing_table(row_to_write);
            if spare_block_num > 0 % The block is paired
                %write to spare block
                obj.Memory.writeToRow(spare_block_num, writes_performed);
                spare_block_dead_bits = find(obj.Memory.dead_bit_table(spare_block_num, :) > 0);
                primary_block_dead_bits = find(obj.Memory.dead_bit_table(row_to_write, :) > 0);
                dead_bits_on_both
                % 1. check if the spare block is dead
                % 2. if dead, get new spare block
            else
                obj.Memory.writeToRow(row_ro_write, writes_performed);
                num_of_dead_bits = length(find(obj.Memory.dead_bit_table(row_to_write, :) > 0));
                if num_of_dead_bits > obj.ECP_MAX_ERRORS_CORRECTED
                    pairBlock(obj, row_to_write)
                end
            end
        end
        
        function obj = makeAllPageBlocksSpare(obj, block_num)
            page_num = obj.Memory.get_page_num_of_block(block_num);
            obj.Memory.active_rows_array((page_num-1)*obj.PAGE_ROWS+1 : page_num*obj.PAGE_ROWS) = 0;
            for i=1:1:obj.PAGE_ROWS
                Enqueue(obj.spare_blocks_queue, (page_num-1)*obj.PAGE_ROWS+i);
            end
            obj.num_of_spare_block = obj.num_of_spare_block + obj.PAGE_ROWS;
        end
        
        function obj = pairBlock(obj, bad_block_num)
            if ~isempty(obj.spare_blocks_queue) % Pair the bad block
                obj.block_pairing_table(bad_block_num) = DequeueSpareBlock(obj.spare_blocks_queue);
                obj.num_of_spare_blocks = length(obj.spare_blocks_queue);
            else
                makeAllPageBlocksSpare(obj, bad_block_num);
            end
        end
             
        function obj = EnqueueSpareBlock(obj, elem)
            obj.spare_blocks_queue = [obj.spare_blocks_queue elem];
        end
        
        function elem = DequeueSpareBlock(obj)
            spare_block_num = length(obj.spare_blocks_queue);
            if spare_block_num < 1
               return;
            end
            elem = obj.spare_blocks_queue(1);
            obj.spare_blocks_queue(1) = [];
        end
    end
end

